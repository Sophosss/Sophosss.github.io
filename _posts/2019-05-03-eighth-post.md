---
title: 计算机网络小知识
author: Sophosss
layout: post
---
1. https 如何防止中间人攻击？

   用非对称算法随机加密出一个对称密钥，然后双方用对称密钥进行通信。具体来说，就是客户端生成一个随机密钥，用服务器的公钥对这个密钥进行非对称加密，服务器用私钥进行解密，然后双方就用这个对称密钥来进行数据加密了。

   通信过程：

   - 客户端将自己支持的加密算法发送给服务器，请求服务器证书；
   - 服务器选取一组加密算法，并将证书返回给客户端；
   - 客户端校验证书合法性，生成随机对称密钥，用公钥加密后发送给服务器；
   - 服务器用私钥解密出对称密钥，返回一个响应，HTTPS连接建立完成；
   - 随后双方通过这个对称密钥进行安全的数据通信。

2. https 握手过程？
   - 客户端请求网址，服务端返回证书公钥。
   - 客户端验证证书是否有效，无效弹出警告框，有效则生成一个随机值，用证书的公钥加密随机值，将加密后的密钥发送给服务端。
   - 服务端用私钥解密密钥，再用密钥加密要发送的内容给客户端。客户端用密钥解密信息。

3. GET 和 POST 方式的区别？
   - 根据 HTTP 规范，GET 用于信息获取，而且应该是安全的和幂等的。
   - 根据 HTTP 规范，POST 表示可能修改变服务器上的资源的请求。
   - GET产生一个TCP数据包；POST产生两个TCP数据包。
   - URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。
- POST 是没有大小限制的。
   
4. http 1.1和http 1.0的区别？

   - HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
- 在HTTP1.0中存在带宽的浪费，不能只请求对象的一部分，请求整个对象，而HTTP1.1在请求头引入了range头域允许只请求资源的某个部分，返回状态码206（Partial Content）。
   - HTTP1.0不支持断点续传。
- 在HTTP1.1中新增了24个错误状态响应码。
   - HTTP1.1的请求消息和响应消息都应支持Host头域

5. 拥塞控制与流量控制？

   - TCP 拥塞控制的目标是最大化利用网络上瓶颈链路的带宽。防止过多的数据注入网络中，使得网络中路由器或链路不致过载。（**慢开始、拥塞避免、快重传、快恢复**）

   - 只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。

   - 流量控制是指点对点通信的控制，做的是抑制发送端发送数据的速率，便于接收端来得及接收。

6. http协议有哪几种请求方式？
   - GET, POST 和 HEAD方、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

7. HTTPS和HTTP的区别主要如下：

   总的来说： HTTPS=SSL+HTTP

   - https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
   - http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
   - http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 （这个只是默认端口不一样，实际上端口是可以改的）。
   - http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

8. HTTP请求报文与响应报文格式
   请求报文包含三部分：
   a、请求行：包含请求方法、URI、HTTP版本信息
   b、请求头部（head）字段
   c、请求内容实体(body)

   响应报文包含三部分：
   a、状态行：包含HTTP版本、状态码、状态码的原因短语
   b、响应头部（head）字段
   c、响应内容(body)实体

9. 为什么不能用两次握手进行连接？

   - 3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

   - 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

10. 如果已经建立了连接，但是客户端突然出现故障了怎么办？
    - TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

11. TIME_WAIT存在的两个理由？

    - 可靠的实现TCP全双工连接的终止

    - 允许老的重复的分节在网络上的消逝