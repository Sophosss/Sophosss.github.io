---
title: 数据库小知识
author: Sophosss
layout: post
---
1. 数据库索引，B+树和HASH中为什么用B+树？
   
   - hash表只能匹配是否相等，不能实现范围查找
   - 当需要按照索引进行order by时，hash值没办法支持排序
   - B+树组合索引可以支持部分索引查询
   - 当数据量很大时，hash冲突的概率也会非常大
- B+树作为索引时，非叶子节点只保存索引，叶子节点才会保存数据，这样方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况
  
2. 聚簇索引和非聚簇索引的区别？

   聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

   聚簇索引是物理地址连续存放的索引，在取区间的时候，查找速度非常快。

3. 内连接，外（左右）链接，全连接的区别？
   - left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。
   - right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。
   - inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。
   - full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。

4. join on 后and条件和where后加and条件区别？

   - left join 不管 on 上的条件是否为真都会返回 left 或 right 表中的记录。

   - on是在生成连接表的起作用的，where是生成连接表之后对连接表再进行过滤。
   - 使用inner join时，功能与where完全相同。

5. B+树的特点？

   - 关键字数和子树相同。

   - 非叶子节点仅用作索引，不含数据信息。它的关键字和子节点有重复元素。

   - 叶子节点用指针连在一起，构成有序链表。

6. 数据库隔离级别及实现原理？

   - 读未提交

     - 事务对当前被读取的数据不加锁；

     - 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 **行级共享锁**，直到事务结束才释放。

   - 读提交

     - 事务对当前被读取的数据加 **行级共享锁（当读到时才加锁）**，一旦读完该行，立即释放该行级共享锁；
     - 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 **行级排他锁**，直到事务结束才释放。

   - 可重复读

     - 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 **行级共享锁**，直到事务结束才释放；
     - 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 **行级排他锁**，直到事务结束才释放。

   - 串行化

     - 事务在读取数据时，必须先对其加 **表级共享锁** ，直到事务结束才释放；
     - 事务在更新数据时，必须先对其加 **表级排他锁** ，直到事务结束才释放。

7. 索引的数据结构？

   hash结构，二叉搜索树，红黑树，B树（文件索引），B+树（数据库索引）。

8. 数据库索引为什么要用b+树不用红黑树？

   操作系统读写磁盘的基本单位是扇区，而文件系统的基本单位是簇，磁盘读写有一个最少内容的限制。由于 B+ 树分支比二叉树更多，所以相同数量的内容，B+ 树的深度更浅，代表更少的 IO 次数。

   数据库设计的时候 B+ 树有多少个分支都是按照磁盘一个簇上最多能放多少节点设计。

9. 什么是事务？

   事务是逻辑上的一组操作，要么都执行，要么都不执行。

   四大特性（ACID）：原子性，一致性，隔离性，持久性

   并发事务带来的问题：脏读，丢失修改，不可重复读，幻读

   - 不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。

   | 隔离级别         | 脏读 | 不可重复读 | 幻读 |
   | ---------------- | :--: | :--------: | :--: |
   | READ-UNCOMMITTED |  √   |     √      |  √   |
   | READ-COMMITTED   |  ×   |     √      |  √   |
   | REPEATABLE-READ  |  ×   |     ×      |  √   |
   | SERIALIZABLE     |  ×   |     ×      |  ×   |

   MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。使用 Next-Key Lock  锁算法，因此可以避免幻读的产生，即达到了 SQL标准的 **SERIALIZABLE(可串行化)** 隔离级别。

10. MySQL 大表优化？
    - 限定数据的范围：务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。
    - 读写分离：经典的数据库拆分方案，主库负责写，从库负责读。
    - 垂直分区：根据数据库里面数据表的相关性进行拆分。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。
    - 水平分区：水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。水平拆分最好分库。

11. where 和 having 的异同？

    功能用法相同，执行时机不同。都从from获得的数据源中进行筛选。

    - where 在开始时执行检测数据，对原数据进行过滤，having 对筛选出的结果再次进行过滤。
    - having 字段必须是查询出来的，where 字段必须是数据表存在的。
    - where 不可以使用字段的别名，以及聚合函数（sum()、count()、avg()），having可以。

12. group by 和 order by 区别？
    - group by 是按照哪个字段进行分组，比如按照名字分组，则是所有名字相同的分为一组。在一些计数及求和中用到最多。
    - order by 是按哪个字段进行排序。

