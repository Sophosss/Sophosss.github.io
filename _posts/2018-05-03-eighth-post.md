---
title: Computer Networks
author: Sophosss
layout: post
---
1. https 如何防止中间人攻击？

   用非对称算法随机加密出一个对称密钥，然后双方用对称密钥进行通信。具体来说，就是客户端生成一个随机密钥，用服务器的公钥对这个密钥进行非对称加密，服务器用私钥进行解密，然后双方就用这个对称密钥来进行数据加密了。

   通信过程：

   - 客户端将自己支持的加密算法发送给服务器，请求服务器证书；
   - 服务器选取一组加密算法，并将证书返回给客户端；
   - 客户端校验证书合法性，生成随机对称密钥，用公钥加密后发送给服务器；
   - 服务器用私钥解密出对称密钥，返回一个响应，HTTPS连接建立完成；
   - 随后双方通过这个对称密钥进行安全的数据通信。

2. https 握手过程？
   - 客户端请求网址，服务端返回证书公钥。
   - 客户端验证证书是否有效，无效弹出警告框，有效则生成一个随机值，用证书的公钥加密随机值，将加密后的密钥发送给服务端。
   - 服务端用私钥解密密钥，再用密钥加密要发送的内容给客户端。客户端用密钥解密信息。

3. GET 和 POST 方式的区别？
   - 根据 HTTP 规范，GET 用于信息获取，而且应该是安全的和幂等的。
   - 根据 HTTP 规范，POST 表示可能修改变服务器上的资源的请求。
   - GET产生一个TCP数据包；POST产生两个TCP数据包。
   - URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。
- POST 是没有大小限制的。
  
4. HTTP/1.0、HTTP/1.1、HTTP/2.0的区别？

   HTTP/1.0
   
   - 请求与响应支持头域
   - 响应对象以一个响应状态行开始
   - 响应对象不只限于超文本
   - 开始支持客户端通过POST方法向Web服务器提交数据，支持GET、HEAD、POST方法
   - 支持长连接（但默认还是使用短连接），缓存机制，以及身份认证
   
   HTTP/1.0
   
   - 默认为长连接
   
     HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
   
   - 提供了范围请求功能(宽带优化)
   
     HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。这是支持文件断点续传的基础。
   
   - 提供了虚拟主机的功能(HOST域)
   
     在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
   
   - 多了一些缓存处理字段
   
     HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头。
   
     -错误通知的管理
   
     在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
   
   HTTP/2.0
   
   - 二进制分帧
   
     HTTP 2.0 的所有帧都采用二进制编码
   
     - 帧：客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位。
     - 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。
     - 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2 … N）；
   
   - 多路复用
   
     多路复用允许同时通过单一的HTTP/2.0 连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP/2.0不再依赖多个TCP 连接去处理更多并发的请求。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级。最后再在另一端根据每个帧首部的流标识符把它们重新组合起来。HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。
   
   - 头部压缩
   
     HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。
   
   - 请求优先级
   
     浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。
   
   - 服务端推送
   
     服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。
5. 拥塞控制与流量控制？

   - TCP 拥塞控制的目标是最大化利用网络上瓶颈链路的带宽。防止过多的数据注入网络中，使得网络中路由器或链路不致过载。（**慢开始、拥塞避免、快重传、快恢复**）

   - 只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。

   - 流量控制是指点对点通信的控制，做的是抑制发送端发送数据的速率，便于接收端来得及接收。

6. http协议有哪几种请求方式？
   
- GET, POST 和 HEAD方、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。
  
7. HTTPS和HTTP的区别主要如下：

   总的来说： HTTPS=SSL+HTTP

   - https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
   - http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
   - http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 （这个只是默认端口不一样，实际上端口是可以改的）。
   - http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

8. HTTP请求报文与响应报文格式
   请求报文包含三部分：
   a、请求行：包含请求方法、URI、HTTP版本信息
   b、请求头部（head）字段
   c、请求内容实体(body)

   响应报文包含三部分：
   a、状态行：包含HTTP版本、状态码、状态码的原因短语
   b、响应头部（head）字段
   c、响应内容(body)实体

9. 三次握手的过程：

   - 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

   - 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

   - 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

10. 四次挥手的过程：

   - 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

   - 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

   - 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

   - 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

11. 为什么不能用两次握手进行连接？

    - 3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
    - 第三次握手的作用：防止已失效的连接请求报文段突然又传送到了服务器。
    - Client向Server发出TCP连接请求，第一个连接请求报文在网络的某个节点长时间滞留，Client超时后认为报文丢失，于是再重传一次连接请求,Server收到后建立连接。数据传输完毕后双方断开连接。而此时,前一个滞留在网络中的连接请求到达了服务端Server，而Server认为Client又发来连接请求,若采用的是“两次握手”，则这种情况下Server认为传输连接已经建立，并一直等待Client传输数据，而Client此时并无连接请求，因此不予理睬，这样就造成了Server的资源白白浪费了；但此时若是使用“三次握手”，则Server向Client返回确认报文段，由于是一个失效的请求，因此Client不予理睬，建立连接失败。
    - 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

12. 如果已经建立了连接，但是客户端突然出现故障了怎么办？

    - TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

13. 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
    - Client的最后一个ACK报文在传输的时候丢失，Server并没有接收到这个报文。这个时候，Server就会超时重传这个FIN消息，然后Client就会重新返回最后一个ACK报文，等待两个时间周期，完成关闭。如果不等待这两个时间周期，Server重传的那条消息就不会收到。Server就因为接收不到Client的信息而无法正常关闭。
    - 防止“已失效的连接请求报文段”出现在本连接中。在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种就得连接请求报文段。

14. 如何理解TCP面向字节流，UDP面向报文段？

    - 问题的关键在于TCP是有缓冲区，作为对比，UDP面向报文段是没有缓冲区的。

    - TCP发送报文时，是将应用层数据写入TCP缓冲区中，然后由TCP协议来控制发送这里面的数据，而发送的状态是按字节流的方式发送的，跟应用层写下来的报文长度没有任何关系，所以说是流。

    - 作为对比的UDP，它没有缓冲区，应用层写的报文数据会直接加包头交给网络层，由网络层负责分片，所以是面向报文段的。发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，也就是说无论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。

15. TCP & UDP总结

    - TCP：面向连接，提供可靠的服务，有流量控制，拥塞控制，无重复、无丢失、无差错，面向字节流(把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块)，只能是点对点，首部 20 字节，全双工。

    - UDP：无连接，尽最大努力交付，没有拥塞控制，面向报文(对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部)，支持一对一、一对多、多对多，首部 8 字节。

16. 304状态码

    浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。